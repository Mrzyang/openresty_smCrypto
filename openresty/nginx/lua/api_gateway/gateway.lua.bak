-- API网关主入口
local request_validator = require "request_validator"
local response_handler = require "response_handler"
local redis_utils = require "optimized_redis_utils"
local context = require "context"
local cjson = require "cjson"

local _M = {}

-- 主处理函数
function _M.handle_request()
    -- 获取请求信息
    local method = ngx.var.request_method
    local uri = ngx.var.uri
    local query_string = ngx.var.query_string
    
    -- 获取请求头
    local headers = ngx.req.get_headers()
    local appid = headers["X-App-ID"]
    
    -- 读取请求体
    ngx.req.read_body()
    local body = ngx.req.get_body_data()
    
    -- 检查必需的请求头
    if not appid then
        ngx.status = 400
        ngx.say('{"error":"Missing required header: X-App-ID"}')
        return
    end
    
    -- 1. 验证请求
    local is_valid, result = request_validator.validate_request(appid, method, uri, query_string, body, headers)
    
    if not is_valid then
        -- 处理验证失败
        local error_code = 400
        local api_id = "unknown"
        
        -- 根据错误类型设置不同的状态码
        if string.find(tostring(result), "not found") then
            error_code = 404
        elseif string.find(tostring(result), "disabled") then
            error_code = 403
        elseif string.find(tostring(result), "signature") then
            error_code = 401
        elseif string.find(tostring(result), "whitelist") then
            error_code = 403
        elseif string.find(tostring(result), "Nonce already used") then
            error_code = 409
        elseif string.find(tostring(result), "Timestamp out of window") then
            error_code = 408
        end
        
        local error_response = response_handler.handle_error_response(error_code, tostring(result), appid, api_id)
        ngx.status = error_code
        ngx.say(error_response)
        return
    end
    
    -- 设置上下文中的App配置和API配置，供其他模块使用
    context.set_app_config(result.app_config)
    
    -- 获取解密后的请求体（在验证过程中已经解密）
    local decrypted_body = nil
    if body and body ~= "" then
        -- 从验证结果中获取解密后的请求体
        decrypted_body = result.decrypted_body or body
    end
    
    -- 2. 请求验证通过，代理到后端服务
    -- 使用ngx.location.capture代理请求到内部location
    -- 保持原始URI，Nginx配置会正确处理路径映射
    local backend_uri = uri
    
    -- 根据原始请求方法设置代理方法
    local http_method = ngx.HTTP_GET
    if method == "POST" then
        http_method = ngx.HTTP_POST
    elseif method == "PUT" then
        http_method = ngx.HTTP_PUT
    elseif method == "DELETE" then
        http_method = ngx.HTTP_DELETE
    elseif method == "PATCH" then
        http_method = ngx.HTTP_PATCH
    end
    
    -- 构造传递给后端的请求头
    local backend_headers = {}
    for k, v in pairs(headers) do
        -- 移除签名相关的头部，避免后端处理
        if k ~= "x-signature" and k ~= "x-nonce" and k ~= "x-timestamp" then
            backend_headers[k] = v
        end
    end
    
    -- 设置正确的Content-Type
    backend_headers["Content-Type"] = "application/json"
    
    local res = ngx.location.capture(
        "/internal_backend" .. backend_uri,
        {
            method = http_method,
            body = decrypted_body,
            headers = backend_headers
        }
    )
    
    -- 检查后端响应
    if res.status >= 500 then
        ngx.status = res.status
        ngx.say('{"error":"Backend service error"}')
        return
    end
    
    -- 3. 处理后端响应
    -- 对于非200状态码的响应，不进行加密和签名
    if res.status == 200 then
        local response_body = response_handler.handle_response(result.app_config, res.body)
        ngx.status = res.status
        ngx.say(response_body)
    else
        -- 对于错误响应，直接返回，不进行加密和签名
        ngx.status = res.status
        ngx.say(res.body)
    end
end

-- 健康检查
function _M.health_check()
    local red, err = redis_utils.get_redis_connection()
    if not red then
        ngx.status = 503
        ngx.say('{"status":"unhealthy","error":"Redis connection failed"}')
        return
    end
    
    redis_utils.close_redis_connection(red)
    
    ngx.status = 200
    ngx.say('{"status":"healthy","timestamp":' .. ngx.time() .. '}')
end

-- 管理接口 - 获取App信息
function _M.get_app_info()
    local appid = ngx.var.arg_appid
    if not appid then
        ngx.status = 400
        ngx.say('{"error":"Missing appid parameter"}')
        return
    end
    
    local app_config, err = redis_utils.get_app_config(appid)
    if not app_config then
        ngx.status = 404
        ngx.say('{"error":"App not found"}')
        return
    end
    
    -- 隐藏敏感信息
    app_config.sm2_private_key = nil
    app_config.sm2_public_key = nil
    app_config.sm4_key = nil
    app_config.sm4_iv = nil
    
    ngx.status = 200
    ngx.say(cjson.encode(app_config))
end

-- 管理接口 - 获取API信息
function _M.get_api_info()
    local api_id = ngx.var.arg_api_id
    if not api_id then
        ngx.status = 400
        ngx.say('{"error":"Missing api_id parameter"}')
        return
    end
    
    local api_config, err = redis_utils.get_api_config(api_id)
    if not api_config then
        ngx.status = 404
        ngx.say('{"error":"API not found"}')
        return
    end
    
    ngx.status = 200
    ngx.say(cjson.encode(api_config))
end

-- 管理接口 - 获取App订阅信息
function _M.get_app_subscriptions()
    local appid = ngx.var.arg_appid
    if not appid then
        ngx.status = 400
        ngx.say('{"error":"Missing appid parameter"}')
        return
    end
    
    local subscriptions, err = redis_utils.get_app_subscriptions(appid)
    if not subscriptions then
        ngx.status = 404
        ngx.say('{"error":"App subscriptions not found"}')
        return
    end
    
    ngx.status = 200
    ngx.say(cjson.encode(subscriptions))
end

return _M